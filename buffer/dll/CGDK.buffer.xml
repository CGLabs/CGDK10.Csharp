<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CGDK.buffer.NET</name>
    </assembly>
    <members>
        <member name="T:CGDK.Attribute.Serializable">
            <summary>
            클래스를 직렬화/역직렬화 대상으로 설정
            </summary>
        </member>
        <member name="M:CGDK.Attribute.Serializable.#ctor">
            <summary>
            생성자
            </summary>
        </member>
        <member name="T:CGDK.Attribute.Field">
            <summary>
            멤버 변수 혹은 Property을 직렬화/역직렬화 대상으로 지정 혹은 제외
            </summary>
            <remarks>
            
            </remarks>
            <param name="is_serializable"></param>
        </member>
        <member name="M:CGDK.Attribute.Field.#ctor(System.Boolean)">
            <summary>
            멤버 변수 혹은 Property을 직렬화/역직렬화 대상으로 지정 혹은 제외
            </summary>
            <remarks>
            
            </remarks>
            <param name="is_serializable"></param>
        </member>
        <member name="P:CGDK.Attribute.Field.IsSerializable">
            <summary>
            직렬화 대상 여부를 얻는다.
            </summary>
            <returns>true:직렬화 대상, false:직렬화 제외</returns>
        </member>
        <member name="T:CGDK.Exception.Serialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:CGDK.Exception.Serialize.#ctor(System.Int64)">
            <summary>
            
            </summary>
            <param name="_offset"></param>
        </member>
        <member name="M:CGDK.Exception.Serialize.#ctor(System.Int64,System.String)">
            <summary>
            
            </summary>
            <param name="_offset"></param>
            <param name="_message"></param>
        </member>
        <member name="P:CGDK.Exception.Serialize.Offset">
            <summary>
            
            </summary>
        </member>
        <member name="T:CGDK.Offset">
            <summary>
            Offset값
            </summary>
            <remarks>
            
            </remarks>
            <param name="_amount"></param>
        </member>
        <member name="M:CGDK.Offset.#ctor(System.Int32@)">
            <summary>
            Offset값
            </summary>
            <remarks>
            
            </remarks>
            <param name="_amount"></param>
        </member>
        <member name="F:CGDK.Offset.amount">
            <summary>
            Offset Bytes수
            </summary>
        </member>
        <member name="T:CGDK.Size">
            <summary>
            크기값
            </summary>
        </member>
        <member name="M:CGDK.Size.#ctor">
            <summary>
            생성자
            </summary>
        </member>
        <member name="M:CGDK.Size.#ctor(System.Int32@)">
            <summary>
            생성자
            </summary>
            <param name="_amount"></param>
        </member>
        <member name="F:CGDK.Size.amount">
            <summary>
            
            </summary>
        </member>
        <member name="T:CGDK.buffer">
            <summary>
            버퍼 클래스
            </summary>
        </member>
        <member name="M:CGDK.buffer.#ctor(System.Byte[]@,System.Int32@,System.Int32@)">
            <summary>
            생성자
            </summary>
            <param name="_buffer">메모리 버퍼</param>
            <param name="_offset">오프셋(bytes)</param>
            <param name="_count">크기(bytes)</param>
        </member>
        <member name="M:CGDK.buffer.#ctor(CGDK.buffer@)">
            <summary>
            얕은 복사 생성자
            </summary>
            <param name="_buffer">원본 버퍼</param>
        </member>
        <member name="M:CGDK.buffer.#ctor(System.Int32@)">
            <summary>
            생성과 동시에 메모리를 할당 받는다.
            </summary>
            <param name="_Size">생성할 메모리 크기</param>
        </member>
        <member name="M:CGDK.buffer.Clone">
            <summary>
            깊은 복사로 복제 생성
            </summary>
            <returns>복제 생성된 버퍼</returns>
            <remarks>
            깊은 복사로 버퍼를 생성한다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.Alloc(System.Int32@)">
            <summary>
            메모리를 할당합니다.
            </summary>
            <param name="_Size">할당할 메모리의 크기</param> 
        </member>
        <member name="M:CGDK.buffer.SetBuffer(System.Byte[],System.Int32@,System.Int32@)">
            <summary>
            배열을 버퍼에 설정
            </summary>
            <param name="_buffer">메모리</param>
            <param name="_offset">오프셋</param>
            <param name="_length">크기</param>
            <exception cref="T:CGDK.Exception.Serialize"></exception>
            <remarks>
            외부에서 할당받은 메모리 배열을 설정한다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.SetBuffer(System.Byte[],System.Int32@)">
            <summary>
            배열을 대상 메모리로 설정
            </summary>
            <param name="_buffer"></param>
            <param name="_offset"></param>
            <exception cref="T:CGDK.Exception.Serialize"></exception>
        </member>
        <member name="M:CGDK.buffer.Clear">
            <summary>
            버퍼를 클리어한다.
            </summary>
            <returns>설정되어 있던 버퍼를 돌려준다.</returns>
            <remarks>
            버퍼를 null로 리셋한다. 오프셋과 크기 모두 0으로 리셋한다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.IsEmpty">
            <summary>
            메모리 배열 존재 여부
            </summary>
            <returns>메모리 배열이 존재하면  true</returns>
            <remarks>
            써넣은 데이터 여부가 아니라 메모리 배열의 할당 여부를 확인한다.<br/>
            Alloc로 메모리를 할당받거나 메모리 배열을 설정했다면 true를 리턴한다.<br/>
            Clear()를 호출하면 할당을 해제할 수 있다.<br/>
            </remarks>
            
        </member>
        <member name="P:CGDK.buffer.Capacity">
            <summary>
            할당 받은 메모리 크기
            </summary>
            <remarks>
            설벙된 메모리 배열의 크기를 돌려준다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.RemainedSize">
            <summary>
            설정된 메모리에서 버퍼의 끝부터 남은 량을 돌려준다.
            즉, Capacity - m_offset - m_count 값이 된다.
            </summary>
            <returns>byte 크기</returns>
        </member>
        <member name="P:CGDK.buffer.Data">
            <summary>
            설정된 메모리 배열(Array와 같은값)
            </summary>
        </member>
        <member name="P:CGDK.buffer.Array">
            <summary>
            메모리 배열(Data와 같은 값)
            </summary>
        </member>
        <member name="P:CGDK.buffer.Offset">
            <summary>
            오프셋 값 (m_offset값)
            </summary>
        </member>
        <member name="P:CGDK.buffer.Count">
            <summary>
            데이터 크기 (m_Count값)
            </summary>
        </member>
        <member name="M:CGDK.buffer.op_Addition(CGDK.buffer@,CGDK.Offset@)">
            <summary>
            오프셋(_offset)만큼 앞을 줄인 버퍼를 얻는다
            </summary>
            <param name="_lhs">완본 버퍼</param>
            <param name="_offset">오프셋</param> 
            <returns>생성된 버퍼</returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)(</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
            <remarks>
            원본 버퍼(_lhs)의 앞쪽을 offset(bytes)만큼 포인터를 옮긴 줄인 버퍼를 얻는다.(Extract한 것과 같은 효과)<br/>
            offset을 옮긴 만큼 크기(count)도 줄인다.(offset이 음수일 경우 반대)<br/>
            원본 버퍼는 변경되지 않으며 메모리를 새로 할당해 복사하지는 않는다.(얕은 복사(swallow copy))<br/>
            즉,CGDK.buffer(_lhs.m_buffer, _lhs.m_offset + _offset.amount, _lhs.m_count - _offset.amount)를  생성한 돌려 받는다.<br/>
            _offset값이 음수도 가능하다.<br/>
            원본 버퍼의 범위를 벗어난 설정을 할 수는 없다.<br/>
            </remarks>
            <example>
            <code>
            	var buf_source = new CGDK.buffer(1000);
            	buf_source.append&lt;int &gt;(100);
            	buf_source.append&lt;int &gt;(10);
            
            	var buf_new = buf_source + CGDK.Offset(4); // 4byte만큼 offset을 준 버퍼를 얻는다.
            	var value = buf_new.extract&lt;int &gt;(); // value값은 10
            </code>
            </example>
        </member>
        <member name="M:CGDK.buffer.op_Addition(CGDK.buffer@,System.Int32@)">
            <summary>
            오프셋(_offset)만큼 앞을 줄인 버퍼를 얻는다(_lhs + CGDK.Offset(_offset)과 동일)
            </summary>
            <param name="_lhs">완본 버퍼</param>
            <param name="_offset">옮길 오프셋값</param> 
            <returns>생성된 버퍼</returns>
            operator + (in buffer _lhs, in Offset _offset)과 동일하다.
        </member>
        <member name="M:CGDK.buffer.op_Subtraction(CGDK.buffer@,CGDK.Offset@)">
            <summary>
            오프셋(_offset)만큼 앞을 늘린 버퍼를 얻는다
            </summary>
            <param name="_lhs">완본 버퍼</param>
            <param name="_offset">오프셋</param> 
            <returns>생성된 버퍼</returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
            <remarks>
            원본 버퍼(_lhs)에서 offset(bytes)만큼 앞쪽으로 포인터를 옮긴 늘린 버퍼를 얻는다.(Extract를 Rollback한 것과 같은 효과)<br/>
            offset을 옮긴 크기(count)는 늘인다.(offset이 음수일 경우 반대)<br/>
            원본 버퍼는 변경되지 않으며 메모리를 새로 할당해 복사하지는 않는다.(얕은 복사(swallow copy))<br/>
            즉,CGDK.buffer(_lhs.m_buffer, _lhs.m_offset - _offset.amount, _lhs.m_count + _offset.amount)를  생성한 돌려 받는다.<br/>
            _offset값이 음수도 가능하다.<br/>
            원본 버퍼의 범위를 벗어난 설정을 할 수는 없다.<br/>
            </remarks>
            <example>
            	var buf_source = new CGDK.buffer(1000);
            	buf_source.append&lt;int &gt;(100);
            	buf_source.append&lt;int &gt;(10);
            
            	var value1 = buf_source.extract&lt;int &gt;(); // value값은 100
            
            	var buf_new = buf_source - CGDK.Offset(4); // 4byte만큼 offset을 앞으로 다시 늘린 버퍼를 얻는다.
            	var value = buf_new.extract&lt;int &gt;(); // value값은 100
            </example>
        </member>
        <member name="M:CGDK.buffer.op_Subtraction(CGDK.buffer@,System.Int32@)">
            <summary>
            앞을 늘린 버퍼를 얻는다(_lhs - CGDK.Offset(_offset)과 동일)
            </summary>
            <param name="_lhs">완본 버퍼</param>
            <param name="_offset">오프셋</param> 
            <returns>생성된 버퍼</returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
            <remarks>
            operator - (in buffer _lhs, in Offset _offset)과 동일하다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.op_Addition(CGDK.buffer@,CGDK.Size@)">
            <summary>
            끝을 늘린 버퍼를 얻는다
            </summary>
            <param name="_lhs">원본 버퍼</param>
            <param name="_size">크기</param>
            <returns>생성된 버퍼</returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
        </member>
        <member name="M:CGDK.buffer.op_Subtraction(CGDK.buffer@,CGDK.Size@)">
            <summary>
            크기(offset)만큼 끝을 줄여 버퍼를 얻는다
            </summary>
            <param name="_lhs">원본 버퍼</param>
            <param name="_size">크기</param>
            <returns>생성된 버퍼</returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
            <remarks>
            '크기'값만큼 버퍼의 크기(count)를 줄인 새로운 버퍼를 돌려준다.<br/>
            원본 버퍼는 변경되지 않으며 메모리를 새로 할당해 복사하지는 않는다.(얕은 복사(swallow copy))<br/>
            즉,CGDK.buffer(_lhs.m_buffer, _lhs.m_offset, _lhs.m_count + _size.amount)를  생성한 돌려 받는다.<br/>
            '크기'값은 음수도 가능하며 음수일 경우 버퍼의 크기를 늘린 버퍼를 돌려준다.<br/>
            원본 버퍼의 범위를 벗어난 설정을 할 수는 없다.<br/>
            </remarks>
        </member>
        <member name="M:CGDK.buffer.op_ExclusiveOr(CGDK.buffer@,CGDK.Offset@)">
            <summary>
            offset을 변경한 버퍼를 얻는다.
            </summary>
            <param name="_lhs">원본 버퍼</param>
            <param name="_offset">오프셋</param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
            <remarks>
            원본 buffer에서 offset만 _offset으로 교체한 버퍼를 돌려준다.<br/>
            원본 버퍼는 변경되지 않으며 메모리를 새로 할당해 복사하지는 않는다.(얕은 복사,swallow copy)<br/>
            즉,CGDK.buffer(_lhs.m_buffer, _offset.amount, _lhs.m_count)를 돌려준다.<br/>
            _offset값은 음수를 허용하지 않는다. 음수일 경우 예뢰를 던집니다.<br/>
            원본 버퍼의 범위를 벗어난 설정을 할 수는 없다.<br/>
            </remarks>
        </member>
        <member name="M:CGDK.buffer.op_ExclusiveOr(CGDK.buffer@,CGDK.Size@)">
            <summary>
            크기를 변경한 버퍼를 얻는다.
            </summary>
            <param name="_lhs">원본 버퍼</param>
            <param name="_count">크기</param>
            <returns></returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
            <remarks>
            원본 buffer에서 크기(size)만 _cize로 교체한 버퍼를 돌려준다.<br/>
            원본 버퍼는 변경되지 않으며 메모리를 새로 할당해 복사하지는 않는다.(얕은 복사,swallow copy)<br/>
            즉,CGDK.buffer(_lhs.m_buffer, _offset.amount, _lhs.m_count)를  돌려준다.<br/>
            _count값은 음수를 허용하지 않습니다. 음수일 경우 예뢰를 던진다.<br/>
            원본 버퍼의 범위를 벗어난 설정을 할 수는 없다.<br/>
            </remarks>
        </member>
        <member name="M:CGDK.buffer.op_ExclusiveOr(CGDK.buffer@,System.ValueTuple{CGDK.Offset,CGDK.Size}@)">
            <summary>
            offset과 count를 동시에 변경한 버퍼를 얻는다.
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns>복제된 buffer</returns>
            <exception cref="T:System.NullReferenceException">원본 버퍼(_lhs)가 비어 있을 경우(m_buffer가 null)</exception>
            <exception cref="T:System.IndexOutOfRangeException">원본 버퍼(_lhs)의 할당된 버퍼 범위를 초과한 경우</exception>
            <remarks>
            원본 buffer의 offset과 크기(size)를 교체한 버퍼를 돌려준다.<br/>
            원본 버퍼는 변경되지 않으며 메모리를 새로 할당해 복사하지는 않는다.(얕은 복사(swallow copy))<br/>
            즉,CGDK.buffer(_lhs.m_buffer, _rhs.offset.amount, _rhs.size.amount)를 돌려준다.<br/>
            _rhs.offset과 _rsh.size 값은 음수를 허용하지 않습니다. 음수일 경우 예뢰를 던진다.<br/>
            원본 버퍼의 할당받은 메모리 범위를 벗어난 설정을 할 수는 없다.<br/>
            </remarks>
        </member>
        <member name="M:CGDK.buffer.op_Implicit(CGDK.buffer@)~System.ArraySegment{System.Byte}">
            <summary>
            [변환 연산자] 버퍼를 ArraySegment로 변환한다.
            </summary>
            <param name="_rhs">원본 버퍼</param>
            <remarks>
            네트워크 송수신시 ArraySegment&lt;byte&gt;형을 요구할 경우가 있다.
            이때 CGDK.buffer를 사용하면 자동적으로 변환된다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.op_Explicit(System.ArraySegment{System.Byte}@)~CGDK.buffer">
            <summary>
            [변환 연산자] ArraySegment를 buffer로 변환한다.
            </summary>
            <param name="_rhs">원본 배열어레이</param>
            <remarks>
            ArraySegment&lt;byte&gt;형으로 buffer를 바로 생성해 사용할 있도록 해준다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.AppendSkip(System.Int32@)">
            <summary>
            써넣지 않고 공간만 추가한다.
            </summary>
            <param name="_amount">Bytes수</param>
            <remarks>
            Bytes수만큼 공간을 띄어야할 경우 사용한다.
            해당 공간은 아무런 데이트를 써넣지 않고 단지 공간의 뛰운다.
            즉, m_count수만 늘린다.
            </remarks>
        </member>
        <member name="M:CGDK.buffer.Append``1(``0@)">
            <summary>
            데이터를 직렬화해 버퍼에 써넣는다.
            </summary>
            <typeparam name="T">직렬화할 대상 클래스</typeparam> 
            <param name="_value">대상 객체</param> 
            <remarks>
            다양한 데이터를 직렬화 하여 버퍼에 써 넣는다.<br/>
            직렬화가 가능한 자료형는 다음과 같다.<br/>
            <br/>
            - 기본적인 자료형(byte, shor, int, long, float 등)<br/>
            - 제네릭형 자료형(List&lt;T&gt;, Dictionary&lt;,V&gt;, ...) <br/>
            - 구조체<br/>
            - 클래스 (attribute의 설정을 필요하다.)<br/>
            - 사용자 정의 클래스 (IBufferSerializer::IBase&lt;T&gt;를 상속받은 객체)<br/>
            <br/>
            정적함수인 GetSizeOf&lt;T&gt;()함수를 하면 직렬화 크기를 미리 얻을 수 있다.<br/>
            </remarks>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.Append``1(System.Collections.Generic.List{``0}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)">
            <summary>
            데이터를 직렬화해 버퍼에 써는 함수이다. 
            </summary>
            <param name="_buffer">메모리 배열 m_buffer에 설정된다.</param>
            <param name="_offset">오프셋</param>
            <param name="_count">복사할 크기</param>
            <remarks>
            </remarks>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.Append``1(System.Collections.Generic.List{``0}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.AppendText(System.String@)">
            <summary>
            헤더 정보 없이 문자열을 직렬화 써넣는다.
            </summary>
            <param name="_object"></param>
            <remarks>
            Append&lt;string&gt;()을 사용해 문자열을 직렬화할 경우 문자열 크기를 써 넣은 후 문자열을 복사해 넣는다.<br/>
            하지만 이 함수는 문자열 크기 정보를 쓰지 않고 바로 문자열을 복사해 넣는다.<br/>
            웹과 같은 문자열 기반 프로토콜 통신을 할 때에도 유용하다.<br/>
            또 화면 출력이나 저장을 위한 문서나 문자열을 만들어야 할 때 유용하다.<br/>
            문자열 끝에 개행이나 NULL을 자동 삽입하지 않으므로 필요하면 직접 써넣어 주어야 한다.<br/>
            </remarks>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.Append``1(System.Collections.Generic.List{``0}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.AppendText(System.Collections.Generic.ICollection{System.String}@)">
            <summary>
            다수의 문자열을 헤더 정보 없이 버퍼에 써넣는다.
            </summary>
            <param name="_Collection">문자열을 담은 Collection</param>
            <remarks>
            Collection을 사용해 다수의 문자열을 한번에 복사해 넣을 때 사용한다.<br/>
            </remarks>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.Append``1(System.Collections.Generic.List{``0}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.AppendText(System.String[])">
            <summary>
            여러 개의 파라미터로 나열된 문자열을 헤더 정보 없이 버퍼에 써넣는다.
            </summary>
            <param name="_Array">문자열드</param>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.Append``1(System.Collections.Generic.List{``0}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)">
            <summary>
            Dictionary&lt;K,V&gt;를 직렬화해 버퍼에 써넣는다.
            </summary>
            <typeparam name="K">Dictionary의 '키' 타입</typeparam>
            <typeparam name="V">Dictionary의 '값' 타입</typeparam>
            <param name="_value">Dictionary 데이터</param>
            <remarks>
            제너릭 타입의 명시 없이 Apppend()를 호출 했을 때 데이터가 Dictionary라면 이 함수가 호출된다.<br/>
            K,V 타입을 알 수 있어 조금 더 나은 성능을 제공해 줄 수 있다.<br/>
            </remarks>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``1(System.Collections.Generic.List{``0}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.Append``1(System.Collections.Generic.List{``0}@)">
            <summary>
            List&lt;K,V&gt;를 직렬화해 버퍼에 써넣는다.
            </summary>
            <typeparam name="T">List의 값 타입</typeparam>
            <param name="_value">List 데이터</param>
            <remarks>
            제너릭 타입의 명시 없이 Apppend()를 호출 했을 때 데이터가 List라면 이 함수가 호출된다.<br/>
            T 타입을 알 수 있어 조금 더 나은 성능을 제공해 줄 수 있다.<br/>
            </remarks>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.Extract``1">
            <summary>
            데이터를 역직렬화한다.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>생성된 객체</returns>
            <remarks>
            T형 데이터를 역직렬화 한다.
            Append&lt;T&gt;로 직렬화한 데이터는 Extract&lt;T&gt;로 역직렬화가 가능하다.
            </remarks>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
            <see cref="M:CGDK.buffer.GetSizeOf``1(``0@)"/>
        </member>
        <member name="M:CGDK.buffer.SetFront``1(``0@,System.Int32@)">
            <summary>
            데이터를 써넣는다.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_object">써넣을 데이터</param>
            <param name="_offset">써넣은 위치 오프셋</param>
            <remarks>
            버퍼의 offset이나 count값을 변경하지 않고 특정 위치에서 값을 써넣는다.<br/>
            Append로 직렬화 후 값을 수정해야할 경우 많이 사용한다.<br/>
            데이터 경계 내만 변경 가능하다.
            </remarks>
            <see cref="M:CGDK.buffer.GetFront``1(System.Int32@)"/>
        </member>
        <member name="M:CGDK.buffer.GetFront``1(System.Int32@)">
            <summary>
            데이터를 읽어낸다.
            </summary>
            <typeparam name="T">일어낼 데이터형</typeparam>
            <param name="_offset">읽은 위치 오프셋</param>
            <returns>읽어낸 데이터</returns>
            <remarks>
            버퍼의 offset이나 count값을 변경하지 않고 특정 위치에서 데이터를 읽어온다.<br/>
            </remarks>
            <see cref="M:CGDK.buffer.SetFront``1(``0@,System.Int32@)"/>
        </member>
        <member name="M:CGDK.buffer.GetSizeOf``1(``0@)">
            <summary>
            데이터의 직렬화 크기를 구한다.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_object"></param>
            <returns></returns>
            <remarks>
            데이터 객체가 직렬화/역직렬화 되었을 때 필요한 크기를 byte단위로 구한다.
            </remarks>
            <see cref="M:CGDK.buffer.Append``1(``0@)"/>
            <see cref="M:CGDK.buffer.AppendSkip(System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append(System.Byte[]@,System.Int32@,System.Int32@)"/>
            <see cref="M:CGDK.buffer.Append``2(System.Collections.Generic.Dictionary{``0,``1}@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String@)"/>
            <see cref="M:CGDK.buffer.AppendText(System.String[])"/>
            <see cref="M:CGDK.buffer.Extract``1"/>
        </member>
        <member name="T:CGDK.BufferSerializer.IBase`1">
            <summary>
            Serializable의 Interface class
            </summary>
            <typeparam name="T">직렬화/역직렬화할 대상 데이터형</typeparam>
        </member>
        <member name="M:CGDK.BufferSerializer.IBase`1.ProcessAppend(System.Byte*@,System.Byte*,`0)">
            <summary>
            직렬화한다.
            </summary>
            <param name="_ptr">버퍼 포인터</param>
            <param name="_ptr_bound">상부 버퍼 경계</param>
            <param name="_object">직렬화할 대상 객체</param>
        </member>
        <member name="M:CGDK.BufferSerializer.IBase`1.ProcessExtract(System.Byte*@,System.Int32@)">
            <summary>
            역직렬화한다.
            </summary>
            <param name="_ptr">버퍼 포인터</param>
            <param name="_count">상부 버퍼 경계</param>
            <returns>역직렬화해 생성한 객체</returns>
        </member>
        <member name="M:CGDK.BufferSerializer.IBase`1.ProcessGetSizeOf(`0)">
            <summary>
            크기를 구한다.
            </summary>
            <param name="_object"></param>
            <returns>대상 객채</returns>
        </member>
        <member name="T:CGDK.BufferSerializer.Get`1">
            <summary>
            데이터형을 Serializer를 얻는다.
            </summary>
            <typeparam name="T">직렬화/역직렬화할 데이터형</typeparam>
        </member>
        <member name="F:CGDK.BufferSerializer.Get`1.instance">
            <summary>
            Serializer
            </summary>
        </member>
        <member name="T:CGDK.BufferSerializer.Custom">
            <summary>
            
            </summary>
        </member>
        <member name="M:CGDK.BufferSerializer.Custom.RegisterSerializer``1(CGDK.BufferSerializer.IBase{``0})">
            <summary>
            커스템 Serializer를 등록한다.(T 인터페이스 Serializer)
            </summary>
            <typeparam name="T">직렬화/역직럴화 데이터형</typeparam>
            <param name="_custom_stablilzer">등록할 Serializer</param>
        </member>
        <member name="M:CGDK.BufferSerializer.Custom.RegisterSerializer``1(CGDK.BufferSerializer.IBase{System.Object})">
            <summary>
            커스템 Serializer를 등록한다.(object 인터페이스 Serializer)
            </summary>
            <typeparam name="T">직렬화/역직럴화 데이터형</typeparam>
            <param name="_custom_stablilzer">등록할 Serializer</param>
        </member>
    </members>
</doc>
